# shellcheck shell=bash
# shellcheck disable=SC2211  # Function names with ? are valid in bash
# shellcheck disable=SC2154  # Variables set in other modules (s_os, s_db_types, s_db_client)

# s.db.sanitize? value type
# Validates and sanitizes database-related inputs to prevent SQL injection
# type: username, database, hostname, grants
# Returns 0 if valid, 2 if invalid
function s.db.sanitize?() {
	test -z "$2" && return 2
	local value="$1"
	local type="$2"
	
	case "$type" in
		username|database)
			# Only allow alphanumeric and underscore, max 64 chars
			if [[ ! "$value" =~ ^[a-zA-Z0-9_]{1,64}$ ]]; then
				s.print.log error "Invalid $type: must be alphanumeric with underscores, max 64 chars"
				return 2
			fi
			;;
		hostname)
			# Allow valid IP addresses or FQDNs
			if [[ ! "$value" =~ ^[a-zA-Z0-9.-]{1,253}$ ]] && [[ ! "$value" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
				s.print.log error "Invalid hostname: must be valid FQDN or IP address"
				return 2
			fi
			;;
		grants)
			# Only allow specific grant keywords
			if [[ ! "$value" =~ ^[A-Z,\ ]+$ ]]; then
				s.print.log error "Invalid grants: must be uppercase SQL keywords separated by commas"
				return 2
			fi
			;;
		*)
			s.print.log error "Unknown sanitization type: $type"
			return 2
			;;
	esac
	return 0
}

# s.db.list.compat? db_type
# Returns true if compatible with db_type, no args lists returns a list
function s.db.list.compat?() {
	local db_type
	if [ -z "$1" ]; then
		for db_type in "${s_db_types[@]}"
		do
			echo "$db_type"
		done
		s.print.log debug "List of compatible databases: ${s_db_types[*]}"
	else
		for db_type in "${s_db_types[@]}"
		do
			if [ "$db_type" == "$1" ]; then
				s.print.log debug "Database $db_type is compatible"
				case $db_type in
					mysql)
						if [ "$s_os" = "Linux" ]; then
							s.check.requirements? "mysql"
							s_db_client=mysql
						elif [ "$s_os" = "Darwin" ]; then
							s.check.requirements? "mysql5"
							s_db_client=mysql5
						else
						s.check.os?
						fi
						;;
				esac
				return 0
			fi
		done
		s.print.log debug "Database $db_type is not compatible"
		return 2
	fi
}

# s.db.check.user? db_type db_host db_user db_password
# Checks if db client exists and can connect to db server
# returns error if it doesn't exists
function s.db.check.user?() {
	test -z "$4" && return
	local db_type=$1
	local db_host=$2
	local db_user=$3
	local db_password=$4
	local db_query="USE mysql"
	
	# Validate inputs
	s.db.sanitize? "$db_host" "hostname" || return $?
	s.db.sanitize? "$db_user" "username" || return $?
	
	s.db.list.compat? "$db_type" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_password" s.process.run "$s_db_client" -h "$db_host" \
						-u "$db_user" \
						--skip-column-names \
						-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Valid database user: $db_user"
	else
		s.print.log error "Can't connect with database server with user $db_user"
	fi		
	return "$exitcode"
}

# s.db.check.database? db_type db_host db_user db_password db_name
# Checks if a database exists
# returns error if it doesn't exists
function s.db.check.database?() {
	test -z "$5" && return
	local db_type=$1
	local db_host=$2
	local db_user=$3
	local db_password=$4
	local db_name=$5
	local db_query="USE $db_name"
	
	# Validate database name
	s.db.sanitize? "$db_name" "database" || return $?
	
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" "$db_user" "$db_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_password" s.process.run "$s_db_client" -h "$db_host" \
						-u "$db_user" \
						--skip-column-names \
						-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Valid database name: $db_name"
	else
		s.print.log error "Can't connect with database name $db_name"
	fi
	return "$exitcode"
}

# s.db.create.user db_type db_host db_root_password db_user db_password
# Creates a user with a password in db server
function s.db.create.user() {
	test -z "$5" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_user=$4
	local db_password=$5
	
	# Validate inputs
	s.db.sanitize? "$db_user" "username" || return $?
	s.db.sanitize? "$db_host" "hostname" || return $?
	
	# Escape single quotes in password to prevent SQL injection
	local escaped_password="${db_password//\'/\'\'}"
	
	local db_query="CREATE USER '$db_user'@'$db_host' IDENTIFIED BY '$escaped_password'; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Database user created: $db_user"
	else
		s.print.log error "Can't create database user: $db_user"
	fi
	return "$exitcode"
}

# s.db.create.database db_type db_host db_root_password db_name
# Creates a new database 
function s.db.create.database() {
	test -z "$4" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_name=$4
	
	# Validate database name
	s.db.sanitize? "$db_name" "database" || return $?
	
	local db_query="CREATE DATABASE $db_name;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Database created: $db_name"
	else
		s.print.log error "Can't create database: $db_name"
	fi
	return "$exitcode"
}

# s.db.set.grants db_type db_host db_root_password db_name db_user "grant1,grantN"
# Set permissions to a specific user access the database
function s.db.set.grants() {
	test -z "$6" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_name=$4
	local db_user=$5
	local db_grants=$6
	
	# Validate inputs
	s.db.sanitize? "$db_name" "database" || return $?
	s.db.sanitize? "$db_user" "username" || return $?
	s.db.sanitize? "$db_host" "hostname" || return $?
	s.db.sanitize? "$db_grants" "grants" || return $?
	
	local db_query="GRANT $db_grants ON ${db_name}.* TO '$db_user'@'$db_host'; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Grants created to user: ${db_user}@${db_host}"
	else
		s.print.log error "Can't create grants to user: ${db_user}@${db_host}"
	fi
	return "$exitcode"
}

# s.db.set.password db_type db_host db_root_password db_user db_password
# Set new password to a specific user
# Compatible with MySQL 5.7+ (avoids deprecated PASSWORD() function)
function s.db.set.password() {
	test -z "$5" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_user=$4
	local db_password=$5
	
	# Validate inputs
	s.db.sanitize? "$db_user" "username" || return $?
	s.db.sanitize? "$db_host" "hostname" || return $?
	
	# Escape single quotes in password to prevent SQL injection
	local escaped_password="${db_password//\'/\'\'}"
	
	# Use ALTER USER instead of deprecated PASSWORD() function (MySQL 8.0+ compatible)
	local db_query="ALTER USER '$db_user'@'$db_host' IDENTIFIED BY '$escaped_password'; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Password changed for user: ${db_user}@${db_host}"
	else
		s.print.log error "Can't change password for user: ${db_user}@${db_host}"
	fi
	return "$exitcode"
}

# s.db.delete.grants db_type db_host db_root_password db_name db_user
# Revoke grants to a user
function s.db.delete.grants() {
	test -z "$5" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_name=$4
	local db_user=$5
	
	# Validate inputs
	s.db.sanitize? "$db_name" "database" || return $?
	s.db.sanitize? "$db_user" "username" || return $?
	s.db.sanitize? "$db_host" "hostname" || return $?
	
	local db_query="REVOKE ALL PRIVILEGES ON ${db_name}.* FROM '$db_user'@'$db_host'; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Removed privileges for user: ${db_user}@${db_host}"
	else
		s.print.log error "Can't remove privileges for user: ${db_user}@${db_host}"
	fi
	return "$exitcode"
}

# s.db.delete.user db_type db_host db_root_password db_user
# Delete a user
function s.db.delete.user() {
	test -z "$4" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_user=$4
	
	# Validate inputs
	s.db.sanitize? "$db_user" "username" || return $?
	s.db.sanitize? "$db_host" "hostname" || return $?
	
	local db_query="DROP USER '$db_user'@'$db_host'; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "User removed: ${db_user}@${db_host}"
	else
		s.print.log error "Can't remove user: ${db_user}@${db_host}"
	fi
	return "$exitcode"
}

# s.db.delete.database db_type db_host db_root_password db_name
# Delete a database
function s.db.delete.database() {
	test -z "$4" && return
	local db_type=$1
	local db_host=$2
	local db_root_password=$3
	local db_name=$4
	
	# Validate database name
	s.db.sanitize? "$db_name" "database" || return $?
	
	local db_query="DROP DATABASE $db_name; FLUSH PRIVILEGES;"
	s.db.list.compat? "$db_type" || return $?
	s.db.check.user? "$db_type" "$db_host" root "$db_root_password" || return $?
	case $db_type in
		mysql)
			# Use MYSQL_PWD environment variable to avoid password in process list
			MYSQL_PWD="$db_root_password" s.process.run "$s_db_client" \
				-h "$db_host" \
				-u root \
				-e "$db_query"
			local exitcode=$?
			;;
	esac
	if [ "$exitcode" -eq 0 ]; then
		s.print.log info "Database removed: $db_name"
	else
		s.print.log error "Can't remove database: $db_name"
	fi
	return "$exitcode"
}
